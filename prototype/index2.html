<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	
    <script type="text/javascript">
       function GetQueryString(name)
        {
             var reg = new RegExp("(^|&)"+ name +"=([^&]*)(&|$)");
             var r = window.location.search.substr(1).match(reg);
             return  !!r?unescape(r[2]):null;
        }
        console.log(decodeURIComponent(GetQueryString('abc')));
    </script>
	<script type="text/javascript">
		/*寄生组合继承，最通用的继承方式*/
        var Parent = function(name){
            this.name = name;
            this.color = ['red', 'blue', 'green'];
        }
        Parent.prototype.getName = function(){
            console.log(this.name)
        }
        var Child = function(name,age){
            Parent.call(this,name);
            this.age = age;
        }
        /*Object.create(proto[,propertiesObject ])*/
        /*
        proto,新创建对象的原型
        propertiesObject,新创建对象的属性与值，其结构类似Object.defineProperties()的第二个参数，如下
        Object.create(proto,{
			test : {
				writable:true,
			    configurable:true,
			    value: "hello" 
			}
        })
         */
        /*继承一个父类*/
        Child.prototype=Object.create(Parent.prototype);
        /*
        继承多个父类
        Object.assign(MyClass.prototype, OtherSuperClass.prototype);
         */
        Child.prototype.constructor=Child;
        Child.prototype.prop = function(){
        	console.log("prop")
        }

        /*实例*/
        var child1 = new Child("youming",18);
        var child2 = new Child("youming",18);
        console.log(Parent.prototype)//{getName: ƒ, constructor: ƒ}  子类增加的方法没有影响父类的原型


        window.addEventListener('storage', function (evt) {
            alert(1)
            //if(evt.key==='msg') console.log(evt.newValue);
        });
	</script>
</body>
</html>